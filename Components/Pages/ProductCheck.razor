@page "/productcheck"
@rendermode InteractiveServer
@using Microsoft.EntityFrameworkCore
@using PickingRoute.Data
@using PickingRoute.Models
@using PickingRoute.Services
@inject ApplicationDbContext dbContext

<h1>ピッキングリスト作成</h1>

@foreach (var item in _productItems)
{
	<ul>
		<li>
			@item.ProductName
			<input type="checkbox" @onclick="() => UpdatePickingList(item)">
		</li>
	</ul>
}

<h2>ピッキングリスト</h2>

<ul>
	@foreach (var item in _PickingItems)
	{
		<li>@item.ProductName</li>
	}
</ul>


<h2>ピッキングルート</h2>
<button　type ="button" class="btn btn-primary" @onclick=" () => CalculateGreedyRoute(_PickingItems)">
	最短経路</button>
<ul>
	@foreach (var item in _optimalRoute)
	{
		<li>@item.ProductName</li>
	}
</ul>

<h2>商品の配置図</h2>
<svg width="800" height="600" style="border : 1px solid black;">
	<!-- 商品の円とテキストを先に描画-->
	@for (int i = 0; i < _optimalRoute.Count; i++)
	{
		var item = _optimalRoute[i];
		var textx = item.strangeLocationX + 10;
		var texty = item.strangeLocationY - 10;

		<!--商品の円を描画-->
		<circle cx="@item.strangeLocationX" cy="@item.strangeLocationY" r="10" fill="blue" />

		<!--商品名を描画-->
		<foreignObject x="@textx" y="@texty" width="200" height="20">
			@(i + 1). @item.ProductName
		</foreignObject>

	}

	<!-- 前面に出すため、商品間の矢印を後に描画する-->
	@for (int i = 0; i < _optimalRoute.Count - 1; i++)
	{
		var item = _optimalRoute[i];
		var nextItem = _optimalRoute[i + 1];

		<!-- 商品間の矢印を描画-->
		<line x1="@item.strangeLocationX" y1="@item.strangeLocationY" x2="@nextItem.strangeLocationX" y2="@nextItem.strangeLocationY" stroke="red" marker-end="url(#arrowhead)" />
	}
	<!--矢印の定義-->
	<defs>
		<marker id="arrowhead" markerWidth="15" markerHeight="10" refX="10" refY="5" orient="auto">
			<polygon points="0 0, 15 5, 0 10" fill="red" />
		</marker>
	</defs>
</svg>

<h2>倉庫内の配置図</h2>
<!-- SVG 要素内でのマウスの動きを追跡 -->
<!--onmousemove と onmouseup を svg タグに設定: SVG全体でマウスの動きを追跡し、確実にイベントをキャッチするため。-->
<svg width="800" height="600" style="border: 1px solid black;" @onmousemove="OnMouseMove" @onmouseup="OnMouseUp">
	@foreach (var shelf in _Shelves) 
	{ 
		<!-- 棚の位置を描画 -->
		<!--onmousedown を rect タグに設定: ドラッグの開始点を正確に特定するため。-->
		<rect x="@shelf.X" y="@shelf.Y" width="50" height="50" fill="lightgray" stroke="black" @onmousedown="(e) => OnMouseDown(e, shelf)" />
		<foreignObject x="@(shelf.X + 5)" y="@(shelf.Y + 25)" width="25" height="20">
			<body xmlns="http://www.w3.org/1999/xhtml">
				<div style="font-size:12px; color:black;">@shelf.Name</div> 
			</body>
		</foreignObject>
	}
</svg>

@code {
	private List<ProductItem> _productItems = new();
	private List<ProductItem> _PickingItems = new();
	private List<ProductItem> _optimalRoute = new();

	private List<Shelf> _Shelves = new();
	private Dictionary<int, ElementReference> shelfElements = new(); 
	private Shelf? draggingShelf; // ドラッグ中の棚
	private bool isDragging = false; // ドラッグ状態のフラグ
	private double offsetX, offsetY;　// マウスと棚の位置のオフセット

	/// <summary>
	/// 初期化処理
	/// 商品一覧を取得する
	/// </summary>
	/// <returns></returns>
	protected override async Task OnInitializedAsync()
	{
		_productItems = await dbContext.ProductItems.ToListAsync();
		_Shelves = await dbContext.Shelves.ToListAsync();
	}

	/// <summary>
	/// ピッキングリストを作成・更新する
	/// </summary>
	/// <param name="item"></param>
	private void UpdatePickingList(ProductItem item)
	{
		if (!_PickingItems.Contains(item))
		{
			_PickingItems.Add(item);
		}
		else
		{
			_PickingItems.Remove(item);
		}
	}

	/// <summary>
	/// 貪欲法を使用して、リスト内の商品を最短距離で並べ替えます。
	/// </summary>
	/// <param name="products"></param>
	/// <returns></returns>
	private void CalculateGreedyRoute(List<ProductItem> products)
	{
		_optimalRoute = new List<ProductItem>();
		var remainingProducts = new List<ProductItem>(products);
		var currentProduct = remainingProducts[0];

		_optimalRoute.Add(currentProduct);
		remainingProducts.RemoveAt(0);

		while (remainingProducts.Any())
		{
			var nextProduct = remainingProducts
			.OrderBy(p => GetDistance(currentProduct, p))
			.First();
			_optimalRoute.Add(nextProduct);
			remainingProducts.Remove(nextProduct);
			currentProduct = nextProduct;
		}
	}

	/// <summary>
	///  ユーグリッド距離を計算します。
	///  2点をまっすぐ結んだ線の長さです。
	/// </summary>
	/// <param name="a"></param>
	/// <param name="b"></param>
	/// <returns></returns>
	private double GetDistance(ProductItem a, ProductItem b)
	{
		return Math.Sqrt(Math.Pow(a.strangeLocationX - b.strangeLocationX, 2) + Math.Pow(a.strangeLocationY - b.strangeLocationY, 2));
	}

	/// <summary> 
	/// マウスダウンイベントハンドラ。対象の棚を特定し、ドラッグを開始する。
	/// </summary> 
	/// <param name="e"></param> 
	/// <param name="shelf"></param>
	private void OnMouseDown(MouseEventArgs e, Shelf shelf) 
	{ 
		draggingShelf = shelf; // ドラッグ中の棚をセット
		isDragging = true;  // ドラッグ中フラグをセット
		offsetX = e.ClientX - shelf.X; // マウスのX座標と棚のX座標の差を計算
		offsetY = e.ClientY - shelf.Y; // マウスのY座標と棚のY座標の差を計算
	}

	/// <summary> 
	/// マウスムーブイベントハンドラ。棚の位置を更新する。
	/// </summary> 
	/// <param name="e"></param>
	private void OnMouseMove(MouseEventArgs e)
	{
		if (isDragging && draggingShelf != null)
		{
			draggingShelf.X = e.ClientX - offsetX; // 新しいX座標を計算
			draggingShelf.Y = e.ClientY - offsetY; // 新しいY座標を計算
			StateHasChanged(); // UIを更新する
		}
	}

	/// <summary> 
	/// マウスアップイベントハンドラ。ドラッグを終了し、新しい位置を保存する。 
	/// </summary> /// <param name="e"></param>
	private async void OnMouseUp(MouseEventArgs e)
	{
		if (isDragging && draggingShelf != null)
		{
			isDragging = false; // ドラッグ中フラグをリセット
			var shelf = await dbContext.Shelves.FindAsync(draggingShelf.Id);
			if (shelf != null)
			{
				shelf.X = draggingShelf.X; // 新しいX座標を保存
				shelf.Y = draggingShelf.Y; // 新しいY座標を保存
				await dbContext.SaveChangesAsync(); // データベースに保存
			}
			draggingShelf = null; // ドラッグ中の棚をリセット
		}
	}

	}
